# -*- coding: utf-8 -*-
"""PremierLeagueWinnerPred.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O7bR0JHVu509eOobfwut8FygsR25U-qw
"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score

import matplotlib.pyplot as plt
import pandas as pd

df=pd.read_csv("matches.csv",index_col=0)

df.head()

# 38 matches x 20 teams x 2 seasons
#to investigate the missing data
38*20*2

#see how many matches each team played
df["team"].value_counts()

df["round"].value_counts()

# cleaning our data
#check the types of data
df.dtypes

df["date"]=pd.to_datetime(df["date"]) #convert the date data type

df.dtypes

#convert venue to a numericvalue
df["venue_code"]=df["venue"].astype("category").cat.codes
#venue code will indicates if the team was home or away by 0 and 1
df

df["opponent_code"]=df["opponent"].astype("category").cat.codes
df

#removing : and minute from the time column
df["hour"]=df["time"].str.replace(":.+","",regex=True).astype("int")
# Get the day of the week as a number from the 'date' column
df["dayCount"]=df["date"].dt.dayofweek
df

#convert the result column to a numeric value
df["target"]=(df["result"]=="W").astype("int")
df

#50 indivisual desicion trees we want to train
model=RandomForestClassifier(n_estimators=300,

    min_samples_split=10,

    random_state=42)

#making sure the training data set is older
train = df[df["date"] < '2022-01-01'].copy()
test = df[df["date"] > '2022-01-01'].copy()

pred=["venue_code","opponent_code","hour","dayCount"]

#training the mode with pred to be able to get the target
model.fit(train[pred],train["target"])

predict=model.predict(test[pred])

accuracy_score(test["target"],predict)

#combining actual and predited values
comp=pd.DataFrame(dict(actual=test["target"],predicted=predict))
pd.crosstab(index=comp["actual"],columns=comp["predicted"])

precision_score(test["target"],predict)*100

#to create a dataframe for each team we have
grouped=df.groupby("team")
group=grouped.get_group("Manchester United")

group

def rollingAverage(group,cols,newCols):
    group=group.sort_values("date")
    rollingStats=group[cols].rolling(3,closed="left").mean()
    group[newCols]=rollingStats
    group=group.dropna(subset=new_cols)
    return group

cols = ["gf", "ga", "sh", "sot", "dist", "fk", "pk", "pkatt"]
new_cols = [f"{c}_rolling" for c in cols]
rollingAverage(group, cols, new_cols)

#to compute the rolling averages function to each team
matchesroll = df.groupby("team").apply(lambda x: rollingAverage(x, cols, new_cols))

#dropping the team index to make it easier accessing each row
matchesroll = matchesroll.droplevel('team')

#assigning values from 0 to r (number of rows we have)
matchesroll.index = range(matchesroll.shape[0])

#retraining our model  with predictions func
def predictions(data, predictors):
    train = data[data["date"] < '2022-01-01']
    test = data[data["date"] > '2022-01-01']
    model.fit(train[predictors], train["target"])
    preds = model.predict(test[predictors])
    combined = pd.DataFrame(dict(actual=test["target"], predicted=preds), index=test.index)
    error = precision_score(test["target"], preds)
    return combined, error

# Ensure the predictors list is correctly formed before calling the function
predict = ["venue_code","opponent_code","hour","dayCount"]
predictors_list = predict + new_cols
combined, error = predictions(matchesroll, predictors_list)

precision_score(combined["actual"], combined["predicted"])*100

combined

combined=combined.merge(matchesroll[["date","team","opponent","result"]],left_index=True,right_index=True)

combined

#to replace any missing name with the original name
class MissingDict(dict):
    __missing__ = lambda self, key: key

map_values = {"Brighton and Hove Albion": "Brighton", "Manchester United": "Manchester Utd", "Newcastle United": "Newcastle Utd", "Tottenham Hotspur": "Tottenham", "West Ham United": "West Ham", "Wolverhampton Wanderers": "Wolves"}
mapping = MissingDict(**map_values)

combined["new_team"] = combined["team"].map(mapping)

#merging the df with itself
merged = combined.merge(combined, left_on=["date", "new_team"], right_on=["date", "opponent"])
merged

merged[(merged["predicted_x"] == 1) & (merged["predicted_y"] ==0)]["actual_x"].value_counts()

accuracy_score(merged["actual_x"], merged["predicted_x"])*100

precision_score(merged["actual_x"], merged["predicted_x"])*100